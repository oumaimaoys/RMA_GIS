{# templates/map.html #}
{% extends "base.html" %}
{% load static %}
{% csrf_token %}

{% block head %}
  {{ block.super }}
  <link rel="stylesheet" href="{% static 'frontend_css/style.css' %}" />
{% endblock %}

{% block title %}Map ‚Äî RMA SIG{% endblock %}

{% block scripts %}
  <!-- (A) Your Leaflet map DIV (fills entire viewport beneath the navbar) -->
<div id="map" style="position:absolute; top:0; bottom:0; right:0; left:0;"></div>

<!--‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   (B) COLLAPSIBLE SIDEBAR WRAPPER
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ-->
<div id="toggle-container-wrapper">
  <!-- (B1) The actual sidebar panel with all your controls -->
  <div id="toggle-container">
    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ SEARCH BOX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <form id="search-box" class="search-box leaflet-control" onsubmit="return false;">
        <input
          id="search-input"
          type="text"
          placeholder="Rechercher une ville"
          autocomplete="off"
        />
        <button type="submit" aria-label="Rechercher"></button>
      </form>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ MANDANTE FILTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <label class="layer-label" for="mandante-filter">Mandante</label>
      <select
        id="mandante-filter"
        style="padding:4px 6px; border-radius:4px; font-size:.9rem;"
      >
        <option value="ALL" selected>Tous</option>
        <!-- options injected by JS once GeoJSON loads -->
      </select>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ PROVINCES / COMMUNES TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <label class="layer-label" for="layer-toggle">Provinces</label>
      <label class="switch">
        <input type="checkbox" id="layer-toggle">
        <span class="slider"></span>
      </label>
      <label class="layer-label" for="layer-toggle">Communes</label>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NORMAL / HEATMAP TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <label class="layer-label" for="heatmap-toggle">Normal</label>
      <label class="switch">
        <input type="checkbox" id="heatmap-toggle">
        <span class="slider"></span>
      </label>
      <label class="layer-label" for="heatmap-toggle">Heatmap</label>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ALL AGENCIES / RMA ONLY TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <label class="layer-label" for="rma-only-toggle">All Agencies</label>
      <label class="switch">
        <input type="checkbox" id="rma-only-toggle">
        <span class="slider"></span>
      </label>
      <label class="layer-label" for="rma-only-toggle">RMA Only</label>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NORMAL / COVERAGE SCORE TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <label class="layer-label" for="score-toggle">Normal</label>
      <label class="switch">
        <input type="checkbox" id="score-toggle">
        <span class="slider"></span>
      </label>
      <label class="layer-label" for="score-toggle">Coverage Score</label>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ NEW SITE BUTTON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <button id="simulateur-btn" class="sim-btn">
        <i class="bi bi-plus-lg"></i> Nouveau site
      </button>
    </div>

    <!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ EXPORT PDF BUTTON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
    <div class="toggle-switch">
      <button id="export-pdf-btn" class="export-btn">
        Export PDF
      </button>
    </div>
  </div>

  <!-- (B2) The small chevron ‚Äúhandle‚Äù that remains visible when collapsed -->
  <div id="sidebar-toggle">
    <i class="bi bi-chevron-left"></i>
  </div>
</div>

<!--‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   (C) INFO CARD ‚Äì appears at bottom‚Äêright when you click a region
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ-->
<div id="info-card">
  <button class="close-btn" aria-label="Close">&times;</button>
  <h3 id="region-name">Region Name</h3>
  <p><strong>Score de couverture&nbsp;(0-100):</strong> <span id="region-score">‚Äî</span></p>
  <p><strong>Potentiel:</strong> <span id="region-potential">‚Äî</span></p>
  <hr>
  <p><strong>Agences RMA:</strong> <span id="region-rma-count">‚Äî</span></p>
  <p><strong>Population:</strong> <span id="region-population">‚Äî</span></p>
  <p><strong>Population assurable:</strong> <span id="region-insured-population">‚Äî</span></p>
  <p><strong>Nombre de v√©hicules estim√©es:</strong> <span id="region-vehicules">‚Äî</span></p>
</div>


  
<div id="loading-screen" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(255, 255, 255, 0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  font-size: 1.5em;
  font-weight: bold;
  color: #333;
">
  Chargement des donn√©es...
</div>
<!-- overlay shown ONLY while the PDF is generated -->
<div id="export-overlay" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,.35);
  display: none;                       /* hidden by default */
  align-items: center; justify-content: center;
  z-index: 10000;
">
  <div style="
      background:#fff;
      padding:26px 32px;
      border-radius:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.3);
      font-size:1.1rem; font-weight:600;
      display:flex; align-items:center; gap:12px;">
    <span id="export-msg">G√©n√©ration du PDF‚Ä¶</span>
    <svg class="spinner" viewBox="0 0 50 50" width="32" height="32">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#d35400"
              stroke-width="5" stroke-linecap="round"
              stroke-dasharray="31.4 31.4">
        <animateTransform attributeName="transform" type="rotate"
                          from="0 25 25" to="360 25 25"
                          dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-providers@1.13.0/leaflet-providers.min.js"></script>      <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-fullscreen@1.6.0/Control.FullScreen.js"></script>                    <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>         <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-minimap@3.6.1/dist/Control.MiniMap.min.js"></script>                 <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.js"></script>                     <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>           <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-hash"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
<script src="https://unpkg.com/leaflet-easyprint@2.1.9/dist/bundle.js"></script> 
<link rel="stylesheet" href="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.css">
<script src="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-providers@1.14.0/leaflet-providers.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>



<script>
  // 1Ô∏è‚É£  create two basemaps + control
  const tomtom = L.tileLayer(
    'https://{s}.api.tomtom.com/maps/orbis/map-display/tile/{z}/{x}/{y}.png' +
    '?apiVersion=1&key=KMOHcDyNXgvQphFMEKmAOPXkr6MLkybG&style=street-light&tileSize=256&view=MA',
    {subdomains:'abc', maxZoom:18, attribution:'¬© TomTom'});

  const sat     = L.tileLayer.provider('Esri.WorldImagery');

  const baseLayers = {
    'TomTom MA': tomtom,
    'Satellite':  sat
  };

  // 2Ô∏è‚É£  init map with TomTom
  const map = L.map('map', {layers:[tomtom]}).setView([31.7, -7.1], 6);
  L.control.layers(baseLayers, null, {position:'bottomleft'}).addTo(map);         // ‚ú± NEW

  // 3Ô∏è‚É£  fullscreen button
  if (L.control.fullscreen)  map.addControl(new L.Control.Fullscreen());

  // 4Ô∏è‚É£  scale bar
  L.control.scale({position:'bottomleft'}).addTo(map);                          // ‚ú± NEW
;                                                                // ‚ú± NEW

  // 7Ô∏è‚É£  geocoder (search bar)
  (function(){
  const form   = document.getElementById('search-box');
  const input  = document.getElementById('search-input');
  const engine = L.Control.Geocoder.nominatim();   // moteur de recherche

  // Emp√™che la carte de bouger quand on clique sur le champ
  L.DomEvent.disableClickPropagation(form);
  L.DomEvent.disableScrollPropagation(form);

  form.addEventListener('submit', e=>{
    e.preventDefault();
    const q = input.value.trim();
    if(!q) return;
    engine.geocode(q, results=>{
      if(results && results.length){
        map.fitBounds(results[0].bbox);   // zoom sur le 1er r√©sultat
      }else{
        alert('Adresse introuvable');
      }
    });
  });
})();                                
    /* -------------------------------------------------------------------- */
  /* 1.  CONFIG ‚Äî tune these to your business meaning                     */
  /* -------------------------------------------------------------------- */
  const SCORE_THRESHOLDS = [          // lower bound of every band
    0, 1, 5, 10, 20, 30, 50, 60, 70, 90
  ];

  const SCORE_COLORS = [
    '#ffffff',  // pale-yellow
    '#ffe082',  // maize
    '#ffc04d',  // mango
    '#ffa600',  // tangerine
    '#ff7b00',  // pumpkin
    '#ff4800',  // vermilion
    '#e31a1c',  // true red
    '#b70026',  // dark red
    '#800026',  // burgundy
    '#4d004b'   // deep purple-red
  ];
    /* -------------------------------------------------------------------- */


  const canvasRenderer = L.canvas({ padding: 0.5 });
  let mandanteFilter = new Set(); 
  let provincesLayer = null;
  let communesLayer = null;
  let agencyLayer = null;
  let currentRegionLayer = null;
  let currentLayerType = 'provinces';
  let heatmapActive = false;
  let rmaOnlyActive = false;
  let rmaData = null;
  let compData = null;
  let provinceRmaCounts = {};
  let communeRmaCounts = {};
  let provinceRmaMin = 0, provinceRmaMax = 1;
  let communeRmaMin = 0, communeRmaMax = 1;
  const hash = new L.Hash(map);
  const SCORE_URL = {
    provinces : "{% url 'province-scores-geojson' %}",
    communes  : "{% url 'commune-scores-geojson' %}"
  };
  let scoreLayer = { provinces:null, communes:null };   // m√©moires s√©par√©es
  let scoreLegend = null;  

  const groups = {
    provinces : L.layerGroup().addTo(map),
    communes  : L.layerGroup().addTo(map)
  };

  function getScoreColor(val){
    if (val == null || isNaN(val)) return '#cccccc';   // missing data
    for (let i = SCORE_THRESHOLDS.length - 1; i >= 0; i--){
      if (val >= SCORE_THRESHOLDS[i]) return SCORE_COLORS[i];
    }
    return SCORE_COLORS[0];                            // safety
  }

  function activeGroup(){
    return groups[currentLayerType];          // renvoie le groupe courant
  }

  function purgeGroup(type){
    groups[type].clearLayers();
  }

  function purgeAll(){
    groups.provinces.clearLayers();
    groups.communes.clearLayers();
    if(scoreLegend)  map.removeControl(scoreLegend);
  }

  // Utility for point in polygon
  function pointInPolygon(point, polygon) {
    const x = point[0], y = point[1];
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.00000001) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Count RMA agencies in each polygon (province/commune)
  function countRmaAgencies(geojson) {
    if (!rmaData) return {};
    const counts = {};
    geojson.features.forEach((feature, idx) => {
      let count = 0;
      const geom = feature.geometry;
      rmaData.features.forEach(pt => {
        const point = pt.geometry.coordinates;
        if (geom.type === "Polygon" && pointInPolygon(point, geom.coordinates[0])) count++;
        if (geom.type === "MultiPolygon" && geom.coordinates.some(poly => pointInPolygon(point, poly[0]))) count++;
      });
      feature.properties.rma_count = count;
      counts[feature.properties.code || idx] = count;
    });
    return counts;
  }

function getHeatColor(val){
   if (val == null || isNaN(val)) return '#cccccc';
   for (let i = SCORE_THRESHOLDS.length - 1; i >= 0; i--){
     if (val >= SCORE_THRESHOLDS[i]) return SCORE_COLORS[i];
   }
   return SCORE_COLORS[0];
 }

  // Style functions
  function provinceStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'blue', weight: 2, fillOpacity: 0.3, fillColor: '#99ccff'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'blue', weight: 2,
      fillOpacity: 0.75,
      fillColor: getHeatColor(count,  provinceRmaMin, provinceRmaMax)
    };
  }
  function communeStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'green', weight: 1, fillOpacity: 0.2, fillColor: '#aee'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'green', weight: 1,
      fillOpacity: 0.7,
      fillColor: getHeatColor(count,  provinceRmaMin, provinceRmaMax)
    };
  }

  // Toggles
  document.getElementById('layer-toggle').addEventListener('change', function(e) {
    currentLayerType = this.checked ? 'communes' : 'provinces';
    resetView();
    loadCurrentLayer();
  });
  document.getElementById('heatmap-toggle').addEventListener('change', function(e) {
    heatmapActive = this.checked;
    loadCurrentLayer();
  });
  document.getElementById('rma-only-toggle').addEventListener('change', function(e) {
    rmaOnlyActive = this.checked;
    // If a region is already selected, reload agencies for that region
    if (currentRegionLayer && currentRegionLayer.feature) {
      loadAgenciesWithinRegion(currentRegionLayer.feature);
    }
  });

  function resetView(){
      purgeAll();               // vide les deux groupes
      clearAgencies();          // (facultatif, pour √™tre s√ªr)
      map.setView([29,-6],6);
      document.getElementById("info-card").style.display = "none";
  }

  function resetAllRegions() {
    if (provincesLayer && currentLayerType === 'provinces') provincesLayer.resetStyle();
    if (communesLayer && currentLayerType === 'communes') communesLayer.resetStyle();
    currentRegionLayer = null;
    document.getElementById("info-card").style.display = "none";
  }

  function highlightRegion(layer) {
    layer.setStyle({
      color: "#d35400",
      weight: 4,
      fillOpacity: 0.5
    });
  }

  function clearAgencies() {
    if (agencyLayer) {
      map.removeLayer(agencyLayer);
      agencyLayer = null;
    }
  }

  // Show either all or only RMA agencies
  function loadAgenciesWithinRegion(regionFeature) {
    if (!compData || !rmaData) return;
    const regionGeometry = regionFeature.geometry;

    function isInRegion(point) {
      if (regionGeometry.type === "Polygon") return pointInPolygon(point, regionGeometry.coordinates[0]);
      if (regionGeometry.type === "MultiPolygon") return regionGeometry.coordinates.some(poly => pointInPolygon(point, poly[0]));
      return false;
    }

    const rmaFiltered = rmaData.features.filter(f => isInRegion(f.geometry.coordinates));
    const compFiltered = rmaOnlyActive ? [] : compData.features.filter(f => {
        if (!isInRegion(f.geometry.coordinates)) return false;

        if (mandanteFilter.size && !mandanteFilter.has('ALL')) {
            const key = (f.properties.mandante || '').trim().toLowerCase();
            return mandanteFilter.has(key);   // same canonical form
        }
        return true;
    });
    const combined = [...rmaFiltered, ...compFiltered];

    if (agencyLayer) map.removeLayer(agencyLayer);

    agencyLayer = L.geoJSON({ type: "FeatureCollection", features: combined }, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => {
      const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        return L.circleMarker(latlng, {
          renderer: canvasRenderer,    
          radius: 6,
          fillColor: isRMA ? "#2980b9" : "#27ae60",
          color: "#fff",
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        if (isRMA) {
          const name = props.name || "Agence RMA";
          const address = props.address || "-";
          const city = props.city || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Adresse:</b> ${address}<br/><b>Ville:</b> ${city}`);
        } else {
          const name = props.company_name || "Agence";
          const address = props.address || "-";
          const city = props.city || "-";
          const mandante = props.mandante || "-";
          const competitor_type = props.competitor_type || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Mandante:</b> ${mandante}<br/><b>Type:</b> ${competitor_type}<br/><b>Adresse:</b> ${address}<br/><b>Localit√©:</b> ${city}`);
        }
      }
    }).addTo(activeGroup());;
  }


  // Event for features
  function onEachFeature(feature, layer) {
    layer.on({
      mouseover: function (e) {
        if (currentRegionLayer !== layer) {
          if (heatmapActive) {
            layer.setStyle({
              fillColor: '#ffd700',
              fillOpacity: 0.8,
              weight: 4,
              color: '#888'
            });
          } else {
            layer.setStyle({
              weight: 4,
              color: '#888',
              fillOpacity: 0.5
            });
          }
        }
        if (feature.properties) {
          const name = feature.properties.name || feature.properties.Nom_Commun || 'Inconnu';
          layer.bindTooltip(`<strong>${name}</strong>`, {
            permanent: false, direction: 'top', offset: [0, -10], sticky: true
          }).openTooltip(e.latlng);
        }
      },
      mouseout: function (e) {
        if (currentRegionLayer !== layer) {
          if (currentLayerType === 'provinces' && provincesLayer) {
            provincesLayer.resetStyle(layer);
          } else if (currentLayerType === 'communes' && communesLayer) {
            communesLayer.resetStyle(layer);
          }
          layer.closeTooltip();
        }
      },
      click: function (e) {
        handleRegionClick(feature, layer);
      }
    });
  }

  function handleRegionClick(feature, layer) {
    if (currentRegionLayer !== layer) {
      resetAllRegions();
      clearAgencies();
      currentRegionLayer = layer;
      highlightRegion(layer);
      map.fitBounds(layer.getBounds());
      loadAgenciesWithinRegion(feature);

      const props = feature.properties;

      // Parse the raw ‚Äúscore‚Äù into a number, then guard with isNaN()
      const rawScore = props.score;
      const parsed   = parseFloat(rawScore);
      const scoreText = (!isNaN(parsed)) ? parsed.toFixed(1) : "‚Äî";

      // For ‚Äúpotential‚Äù, just fall back to ‚Äú‚Äî‚Äù if it‚Äôs falsy
      const potential = props.potential || "‚Äî";

      const name        = props.name || props.Nom_Commun || "Inconnu";
      const rma_count   = props.rma_count || 0;
      const pop         = props.population || props.Population || 0;
      const pop_insured = props.insured_population || 0;
      const vehicles    = props.estimated_vehicles || 0;

      document.getElementById("region-name").textContent           = name;
      document.getElementById("region-score").textContent          = scoreText;
      document.getElementById("region-potential").textContent      = potential;
      document.getElementById("region-rma-count").textContent      = rma_count;
      document.getElementById("region-population").textContent      = pop.toLocaleString();
      document.getElementById("region-insured-population").textContent = pop_insured.toLocaleString();
      document.getElementById("region-vehicules").textContent       = vehicles.toLocaleString();

      document.getElementById("info-card").style.display = "block";
    }
  }

  // Province/Commune loaders
  function loadProvinces() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'provinces-geojson' %}")
    .then(res => res.json())
    .then(provinceData => {
      provinceRmaCounts = countRmaAgencies(provinceData, "province");
      const values = Object.values(provinceRmaCounts);
      provinceRmaMin = Math.min(...values);
      provinceRmaMax = Math.max(...values);

      /* ‚ú± pass renderer */
      provincesLayer = L.geoJSON(provinceData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    provinceStyle,
        onEachFeature
      }).addTo(groups.provinces);

    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

function loadCommunes() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'communes-geojson' %}")
    .then(res => res.json())
    .then(communeData => {
      communeRmaCounts = countRmaAgencies(communeData, "commune");
      const values = Object.values(communeRmaCounts);
      communeRmaMin = Math.min(...values);
      communeRmaMax = Math.max(...values);

      communesLayer = L.geoJSON(communeData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    communeStyle,
        onEachFeature
      }).addTo(groups.communes);
    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

  function showLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "flex";
  }

  function hideLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "none";
  }




  // Load competitor and rma data
  Promise.all([
    fetch("{% url 'competitor-geojson' %}").then(res => res.json()),
    fetch("{% url 'rma-geojson' %}").then(res => res.json())
  ]).then(([comp, rma]) => {
    compData = comp;
    rmaData = rma;
    /* ---------- build unique mandante list ------------ */
    const mandantes = [...new Set(
        compData.features
                .map(f => (f.properties.mandante || '').trim())
                .filter(Boolean)
    )].sort((a, b) => a.localeCompare(b, 'fr', { sensitivity:'base' }));

    /* ---------- build unique mandante list ------------ */
    const seen = new Set();
    const sel  = document.getElementById('mandante-filter');

    compData.features.forEach(f => {
      const raw = (f.properties.mandante || '').trim();
      if (!raw) return;

      const key = raw.toLowerCase();          // canonical form
      if (seen.has(key)) return;              // skip duplicates
      seen.add(key);

      const opt = document.createElement('option');
      opt.value = key;                        // üö© lower-case value
      opt.textContent = raw;                  // nice label
      sel.appendChild(opt);
    });

    /* ---------- listener : update the Set ------------- */
    sel.addEventListener('change', e => {
    const chosen = Array.from(e.target.selectedOptions).map(o => o.value);

    // if ‚ÄúALL‚Äù plus others ‚áí keep only the others
    if (chosen.includes('ALL') && chosen.length > 1) {
        sel.options[0].selected = false;
        chosen.splice(chosen.indexOf('ALL'), 1);
    }

    mandanteFilter = new Set(chosen);       // now contains lower-case keys

    // refresh markers if a region is selected
    if (currentRegionLayer && currentRegionLayer.feature) {
        loadAgenciesWithinRegion(currentRegionLayer.feature);
    }
  });
    loadCurrentLayer(); // call something to decide what to render
  });

  function loadCurrentLayer() {
    purgeGroup(currentLayerType);   // ‚¨ÖÔ∏è  NEW : on efface d‚Äôabord la couche courante

    if (currentLayerType === 'provinces') {
      loadProvinces();
    } else {
      loadCommunes();
    }
  }

  function showExportOverlay(msg='G√©n√©ration du PDF‚Ä¶') {
    document.getElementById('export-msg').textContent = msg;
    document.getElementById('export-overlay').style.display = 'flex';
  }
  function hideExportOverlay() {
    document.getElementById('export-overlay').style.display = 'none';
  }
  

  // Reset/clear on zoom out
  map.on("zoomend", () => {
    if (map.getZoom() < 8) {
      clearAgencies();
      resetAllRegions();
    }
  });
  map.on("zoom", () => {
    if (currentLayerType === 'communes' && map.getZoom() < 10) {
      clearAgencies();
    }
  });

 
function buildScoreLayer(adminType, callback){
  showLoading();
  fetch(SCORE_URL[adminType])
    .then(r => { if(!r.ok) throw Error(r.statusText); return r.json(); })
    .then(fc => {
      const layer = L.geoJSON(fc, {
        style: f => ({
          weight: 1,
          color: '#666',
          fillOpacity: .8,
          fillColor: getScoreColor(f.properties.score)
        }),
        onEachFeature: (f, l) => {
          const s = f.properties.score;
          l.bindPopup(
            `<strong>${f.properties.name}</strong><br>Coverage Score : ` +
            (s != null && !isNaN(s) ? s.toFixed(1) : 'N/A')
          );
        }
      }).addTo(groups[adminType]);

      callback(layer);          // we don't need min/max any more
    })
    .catch(err => alert("Erreur score : " + err))
    .finally(hideLoading);
}

function showScoreLayer(){
    const t = currentLayerType;

    purgeGroup(t);            // ‚¨ÖÔ∏è  ENL√àVE provinces/communes (heat-map ou non)


    // si d√©j√† pr√©sent ‚áí juste l'ajouter
    if(scoreLayer[t]){
        map.addLayer(scoreLayer[t]);
        addOrUpdateLegend();
        return;
    }

    // sinon : t√©l√©charger, construire et m√©moriser
    buildScoreLayer(t, lyr => {
      scoreLayer[t] = lyr;      // store reference
      map.addLayer(lyr);        // display it
      addOrUpdateLegend();      // draw discrete legend
    });
}

function hideScoreLayer(type = currentLayerType){
    if (scoreLayer[type]) {
        map.removeLayer(scoreLayer[type]);
        scoreLayer[type] = null;          // lib√®re la m√©moire
    }
    if (scoreLegend) {
        map.removeControl(scoreLegend);
        scoreLegend = null;
    }
}

function addOrUpdateLegend(){
  if (scoreLegend) map.removeControl(scoreLegend);

  scoreLegend = L.control({position:'bottomright'});
  scoreLegend.onAdd = () => {
    const div = L.DomUtil.create('div','info legend');
    for (let i = SCORE_THRESHOLDS.length - 1; i >= 0; i--){
      const from = SCORE_THRESHOLDS[i];
      const to   = SCORE_THRESHOLDS[i+1];
      div.innerHTML +=
        `<i style="background:${SCORE_COLORS[i]}"></i> ` +
        from + (to ? '&ndash;' + to : '+') + '<br>';
    }
    return div;
  };
  scoreLegend.addTo(map);
}

function clearEverything() {
  // remove all base geo-json
  groups.provinces.clearLayers();
  groups.communes.clearLayers();

  // remove any scoropleth
  Object.values(scoreLayer).forEach(layer => {
    if (layer) { 
      map.removeLayer(layer);
    }
  });
  scoreLayer.provinces = scoreLayer.communes = null;
  if (scoreLegend) { map.removeControl(scoreLegend); scoreLegend = null; }

  // remove agency markers
  if (agencyLayer) {
    map.removeLayer(agencyLayer);
    agencyLayer = null;
  }
}

// Get references to toggles
const scoreToggle = document.getElementById('score-toggle');
const layerToggle = document.getElementById('layer-toggle');
const heatmapToggle = document.getElementById('heatmap-toggle');
const rmaOnlyToggle = document.getElementById('rma-only-toggle');

/* 2-a  Provinces ‚Üî Communes -------------------------------------------------*/
// 1) Layer (Provinces ‚Üî Communes)
layerToggle.addEventListener('change', e => {
  clearEverything();
  currentLayerType = e.target.checked ? 'communes' : 'provinces';
  loadCurrentLayer();
  if (scoreToggle.checked) showScoreLayer();
});

// 2) Heatmap on/off
heatmapToggle.addEventListener('change', e => {
  // ‚ûä if the coverage‚Äêscore layer is showing, turn it off
  if (scoreToggle.checked) {
    scoreToggle.checked = false;    // uncheck the score toggle
    hideScoreLayer();               // remove the choropleth + legend
  }

  // ‚ûã now toggle heatmap mode as usual
  heatmapActive = e.target.checked;
  loadCurrentLayer();               // redraw provinces/communes
});

// 3) Coverage-Score on/off
scoreToggle.addEventListener('change', e => {
  // turn off heatmap if needed
  if (e.target.checked && heatmapToggle.checked) {
    heatmapToggle.checked = false;
    heatmapActive = false;
  }
  clearEverything();
  if (e.target.checked) {
    showScoreLayer();
  } else {
    loadCurrentLayer();
  }
});

// 4) RMA-Only just needs to reload the markers on the current region
rmaOnlyToggle.addEventListener('change', e => {
  rmaOnlyActive = e.target.checked;
  if (currentRegionLayer && currentRegionLayer.feature) {
    loadAgenciesWithinRegion(currentRegionLayer.feature);
  }
});

const EXPANDED_SIZE = 8;               // rows to show when open

// 1) Expand when the user clicks or tabs into the control
sel.addEventListener('focus', () => sel.size = EXPANDED_SIZE);

// 2) Collapse when they click somewhere else
sel.addEventListener('blur',  () => sel.size = 1);

// 3) Also collapse right after they make a choice with the mouse
//    (helps on browsers that keep focus inside the select)
sel.addEventListener('change', () => {
  // give the browser a tick to process selection, then collapse
  setTimeout(() => { sel.size = 1; }, 0);
});

</script>
<script>
  /* ------------------------------------------------------------------
   *  SIMULATEUR : draggable marker + instant score
   * ----------------------------------------------------------------*/
  const simuBtn = document.getElementById('simulateur-btn');
  let simuMarker = null;
  let simuTooltip = null;

  function enableSimuMode() {
    // 1. Hide other layers
    if (typeof heatmapToggle !== 'undefined') {
      heatmapToggle.checked = false;
      heatmapActive = false;
    }
    if (typeof scoreToggle !== 'undefined' && scoreToggle.checked) {
      scoreToggle.checked = false;
      if (typeof hideScoreLayer === 'function') hideScoreLayer();
    }

    // 2. Add or reset draggable marker
    if (!simuMarker) {
      simuMarker = L.marker(map.getCenter(), { draggable: true })
        .addTo(map)
        .on('dragend', onSimuDrop);
    } else {
      simuMarker.setLatLng(map.getCenter()).addTo(map);
    }

    simuBtn.classList.add('active');
  }

  function disableSimuMode() {
    if (simuMarker) map.removeLayer(simuMarker);
    if (simuTooltip) {
      map.closePopup(simuTooltip);
      simuTooltip = null;
    }
    simuBtn.classList.remove('active');
    simuBtn.textContent = '‚ûï Nouveau site';
  }

  function onSimuDrop() {
    const { lat, lng } = simuMarker.getLatLng();
    console.log("üìç Simulateur ‚ûû lat/lon:", lat, lng);

    simuBtn.textContent = '‚è≥ Simulation...';

    fetch("{% url 'simulate-score' %}", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken
      },
      body: JSON.stringify({ lat, lon: lng })
    })
    .then(async r => {
      if (!r.ok) {
        const errorText = await r.text();
        throw new Error(`HTTP ${r.status} ‚Äì ${errorText}`);
      }
      return r.json();
    })
    .then(data => {
      const scoreValue = data.score; // Accessing the top-level score
      const potentialCategory = data.overall_score.potential_category;
      const travelTime = data.key_metrics.travel_time_to_centroid_minutes;
      const areaName = data.area_info.name;

      const html = `
          <strong>üìç Simulation de site</strong><br>
          Score : <b>${scoreValue !== null && scoreValue !== undefined ? scoreValue.toFixed(1) : 'N/A'}</b><br>
          Potentiel : <b>${potentialCategory || 'N/A'}</b><br>
          Temps d'acc√®s : <b>${travelTime !== null && travelTime !== undefined ? travelTime.toFixed(1) : '‚Äì'} min</b><br>
          <hr style="margin: 4px 0;">
          <small style="font-size: 0.8em;">Zone : ${areaName || 'N/A'}</small>
      `;

      // Optional: include component scores
      /*
      const comp = data.component_scores;
      html += `
        <br><u>Composantes</u><br>
        üìà Demande: ${comp.demand}<br>
        ‚öîÔ∏è Concurrence: ${comp.competition}<br>
        üí∞ √âconomie: ${comp.economic}<br>
        üöó Acc√®s: ${comp.accessibility}<br>
        ‚ö†Ô∏è Risque: ${comp.risk}
      `;
      */

      if (simuTooltip) {
        simuTooltip.setContent(html).setLatLng([lat, lng]);
      } else {
        simuTooltip = L.popup()
          .setContent(html)
          .setLatLng([lat, lng])
          .openOn(map);
      }
    })
    .catch(err => {
      console.error('üõë Simulateur erreur:', err);
      alert('Erreur simulateur:\n' + err.message);
    })
    .finally(() => {
      simuBtn.textContent = '‚ûï Nouveau site';
    });
  }

  // Toggle button behavior
  simuBtn.addEventListener('click', e => {
    e.preventDefault();
    if (simuMarker && map.hasLayer(simuMarker)) {
      disableSimuMode();
    } else {
      enableSimuMode();
    }
  });
</script>

<script>
  /* ---------------- CSRF helper ---------------- */
  // Better CSRF token retrieval
  function getCSRFToken() {
      // Try multiple methods
      let token = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!token) {
          token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
      }
      if (!token) {
          const cookieMatch = document.cookie.match(/csrftoken=([^;]*)/);
          token = cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;
      }
      return token;
  }

  const csrftoken = getCSRFToken();

async function exportPdf() {
  console.log('üî• exportPdf function started!');
  try {
    /* 1Ô∏è‚É£  Capture the map ------------------------------------------------ */
    showExportOverlay('Capture de la carte‚Ä¶');
    const imgData = await new Promise((resolve, reject) => {
      leafletImage(map, (err, canvas) => {
        if (err) return reject(err);
        resolve(canvas.toDataURL('image/png'));   // crisp PNG
      });
    });
    console.log('‚úÖ Map captured, size:', imgData.length);

    /* 2Ô∏è‚É£  Build payload -------------------------------------------------- */
    const payload = {
      img:   imgData,
      title: document.getElementById('region-name')?.textContent || 'Vue g√©n√©rale',
      kpis: {
        score:      document.getElementById('region-score')?.textContent,
        potential:  document.getElementById('region-potential')?.textContent,
        population: document.getElementById('region-population')?.textContent,
        insured:    document.getElementById('region-insured-population')?.textContent,
        vehicles:   document.getElementById('region-vehicules')?.textContent,
        rma:        document.getElementById('region-rma-count')?.textContent
      }
    };

    /* 3Ô∏è‚É£  Send to backend ------------------------------------------------- */
    showExportOverlay('G√©n√©ration du PDF‚Ä¶');
    const res = await fetch("{% url 'export-pdf' %}", {
      method:      'POST',
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken':  csrftoken                  // <-- token you fetched earlier
      },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const txt = await res.text();
      hideExportOverlay();
      console.error('‚ùå Error response:', txt);
      alert('Erreur lors de la cr√©ation du PDF (' + res.status + '): ' + txt);
      return;
    }

    /* 4Ô∏è‚É£  Download ------------------------------------------------------- */
    showExportOverlay('T√©l√©chargement‚Ä¶');
    const blob = await res.blob();
    saveAs(blob, 'RMA_report.pdf');
    console.log('‚úÖ PDF export completed!');

  } catch (err) {
    console.error('üí• Error in exportPdf:', err);
    alert('Erreur: ' + err.message);
  } finally {
    hideExportOverlay();                 // always hide, success or fail
  }
}
  // Better event listener attachment
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, looking for export button...');
    const exportBtn = document.getElementById('export-pdf-btn');
    
    if (!exportBtn) {
        console.error('‚ùå Export PDF button not found!');
        return;
    }
    
    console.log('‚úÖ Export PDF button found');
    exportBtn.addEventListener('click', function(e) {
        console.log('üñ±Ô∏è Export button clicked!');
        e.preventDefault(); // Prevent any default behavior
        exportPdf();
    });
});

</script>
<script>
 document.addEventListener("DOMContentLoaded", function () {
  const sidebarToggle   = document.getElementById("sidebar-toggle");
  const toggleContainer = document.getElementById("toggle-container");
  const infoCard        = document.getElementById("info-card");
  const infoCloseBtn    = infoCard.querySelector(".close-btn");

  // 1) Clicking the chevron handle should collapse/expand the sidebar panel
  sidebarToggle.addEventListener("click", () => {
    // Toggle ‚Äúcollapsed‚Äù on the panel
    toggleContainer.classList.toggle("collapsed");
    // Toggle ‚Äúcollapsed‚Äù on the chevron itself (so the arrow flips)
    sidebarToggle.classList.toggle("collapsed");
  });

  // 2) Hide the info card when its ‚Äú√ó‚Äù is clicked
  infoCloseBtn.addEventListener("click", () => {
    infoCard.style.display = "none";
  });
});
</script>
{% endblock %}
