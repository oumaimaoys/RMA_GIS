{# templates/map.html #}
{% extends "base.html" %}
{% load static %}

{% block head %}
  {{ block.super }}
  <link rel="stylesheet" href="{% static 'frontend_css/style.css' %}" />
{% endblock %}

{% block title %}Map ‚Äî RMA SIG{% endblock %}

{% block scripts %}
<div id="toggle-container">
  <div class="toggle-switch" style="margin-left: 38px;">
    <span class="layer-label">Provinces</span>
    <label class="switch">
      <input type="checkbox" id="layer-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Communes</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px; margin-left: 38px;">
    <span class="layer-label">Normal</span>
    <label class="switch">
      <input type="checkbox" id="heatmap-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Heatmap</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px;">
    <span class="layer-label">All Agencies</span>
    <label class="switch">
      <input type="checkbox" id="rma-only-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">RMA Only</span>
  </div>
  <!-- Export button -->
  <button id="export-pdf-btn" class="export-btn"
          style="margin-top:8px;margin-left:38px;padding:6px 14px;
                background:#d35400;color:#fff;border:none;border-radius:6px;
                cursor:pointer;">
    Export PDF
  </button>
</div>

<div id="info-card" style="display: none; min-width: fit-content;">
  <h3 id="region-name"></h3>
  <!-- NEW -->
  <p><strong>Score de couverture&nbsp;(0-100):</strong>
     <span id="region-score"></span></p>
  <p><strong>Potentiel:</strong>
     <span id="region-potential"></span></p>

  <hr>
  <p><strong>Agences RMA:</strong> <span id="region-rma-count"></span></p>
  <p><strong>Population:</strong> <span id="region-population"></span></p>
  <p><strong>Population assurable:</strong> <span id="region-insured-population"></span></p>
  <p><strong>Nombre de vehicules estim√©es:</strong> <span id="region-vehicules"></span></p>
</div>

  
<div id="map"></div>
<div id="loading-screen" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(255, 255, 255, 0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  font-size: 1.5em;
  font-weight: bold;
  color: #333;
">
  Chargement des donn√©es...
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-hash"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>


<script>
  const map = L.map("map").setView([29, -6], 6);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {maxZoom: 18}).addTo(map);
  const canvasRenderer = L.canvas({ padding: 0.5 });


  let provincesLayer = null;
  let communesLayer = null;
  let agencyLayer = null;
  let currentRegionLayer = null;
  let currentLayerType = 'provinces';
  let heatmapActive = false;
  let rmaOnlyActive = false;
  let rmaData = null;
  let compData = null;
  let provinceRmaCounts = {};
  let communeRmaCounts = {};
  let provinceRmaMin = 0, provinceRmaMax = 1;
  let communeRmaMin = 0, communeRmaMax = 1;
  const hash = new L.Hash(map);
  // Utility for point in polygon
  function pointInPolygon(point, polygon) {
    const x = point[0], y = point[1];
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.00000001) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Count RMA agencies in each polygon (province/commune)
  function countRmaAgencies(geojson) {
    if (!rmaData) return {};
    const counts = {};
    geojson.features.forEach((feature, idx) => {
      let count = 0;
      const geom = feature.geometry;
      rmaData.features.forEach(pt => {
        const point = pt.geometry.coordinates;
        if (geom.type === "Polygon" && pointInPolygon(point, geom.coordinates[0])) count++;
        if (geom.type === "MultiPolygon" && geom.coordinates.some(poly => pointInPolygon(point, poly[0]))) count++;
      });
      feature.properties.rma_count = count;
      counts[feature.properties.code || idx] = count;
    });
    return counts;
  }

  function getColorGradient(val, min, max) {
    const ratio = (val - min) / (max - min + 0.00001);
    if (isNaN(ratio) || max == min) return '#eee';
    const r = Math.floor(255 * Math.min(2 * ratio, 1));
    const g = Math.floor(255 * Math.min(2 * (1 - ratio), 1));
    const b = Math.floor(255 * (1 - ratio));
    return `rgb(${r},${g},${b})`;
  }

  // Style functions
  function provinceStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'blue', weight: 2, fillOpacity: 0.3, fillColor: '#99ccff'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'blue', weight: 2,
      fillOpacity: 0.75,
      fillColor: getColorGradient(count, provinceRmaMin, provinceRmaMax)
    };
  }
  function communeStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'green', weight: 1, fillOpacity: 0.2, fillColor: '#aee'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'green', weight: 1,
      fillOpacity: 0.7,
      fillColor: getColorGradient(count, communeRmaMin, communeRmaMax)
    };
  }

  // Toggles
  document.getElementById('layer-toggle').addEventListener('change', function(e) {
    currentLayerType = this.checked ? 'communes' : 'provinces';
    resetView();
    loadCurrentLayer();
  });
  document.getElementById('heatmap-toggle').addEventListener('change', function(e) {
    heatmapActive = this.checked;
    loadCurrentLayer();
  });
  document.getElementById('rma-only-toggle').addEventListener('change', function(e) {
    rmaOnlyActive = this.checked;
    // If a region is already selected, reload agencies for that region
    if (currentRegionLayer && currentRegionLayer.feature) {
      loadAgenciesWithinRegion(currentRegionLayer.feature);
    }
  });

  function resetView() {
    resetAllRegions();
    clearAgencies();
    map.setView([29, -6], 6);
  }

  function resetAllRegions() {
    if (provincesLayer && currentLayerType === 'provinces') provincesLayer.resetStyle();
    if (communesLayer && currentLayerType === 'communes') communesLayer.resetStyle();
    currentRegionLayer = null;
    document.getElementById("info-card").style.display = "none";
  }

  function highlightRegion(layer) {
    layer.setStyle({
      color: "#d35400",
      weight: 4,
      fillOpacity: 0.5
    });
  }

  function clearAgencies() {
    if (agencyLayer) {
      map.removeLayer(agencyLayer);
      agencyLayer = null;
    }
  }

  // Show either all or only RMA agencies
  function loadAgenciesWithinRegion(regionFeature) {
    if (!compData || !rmaData) return;
    const regionGeometry = regionFeature.geometry;

    function isInRegion(point) {
      if (regionGeometry.type === "Polygon") return pointInPolygon(point, regionGeometry.coordinates[0]);
      if (regionGeometry.type === "MultiPolygon") return regionGeometry.coordinates.some(poly => pointInPolygon(point, poly[0]));
      return false;
    }

    const rmaFiltered = rmaData.features.filter(f => isInRegion(f.geometry.coordinates));
    const compFiltered = !rmaOnlyActive ? compData.features.filter(f => isInRegion(f.geometry.coordinates)) : [];
    const combined = [...rmaFiltered, ...compFiltered];

    if (agencyLayer) map.removeLayer(agencyLayer);

    agencyLayer = L.geoJSON({ type: "FeatureCollection", features: combined }, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => {
      const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        return L.circleMarker(latlng, {
          renderer: canvasRenderer,    
          radius: 6,
          fillColor: isRMA ? "#2980b9" : "#27ae60",
          color: "#fff",
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        if (isRMA) {
          const name = props.name || "Agence RMA";
          const address = props.address || "-";
          const city = props.city || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Adresse:</b> ${address}<br/><b>Ville:</b> ${city}`);
        } else {
          const name = props.company_name || "Agence";
          const address = props.address || "-";
          const city = props.city || "-";
          const mandante = props.mandante || "-";
          const competitor_type = props.competitor_type || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Mandante:</b> ${mandante}<br/><b>Type:</b> ${competitor_type}<br/><b>Adresse:</b> ${address}<br/><b>Localit√©:</b> ${city}`);
        }
      }
    }).addTo(map);
  }


  // Event for features
  function onEachFeature(feature, layer) {
    layer.on({
      mouseover: function (e) {
        if (currentRegionLayer !== layer) {
          if (heatmapActive) {
            layer.setStyle({
              fillColor: '#ffd700',
              fillOpacity: 0.8,
              weight: 4,
              color: '#888'
            });
          } else {
            layer.setStyle({
              weight: 4,
              color: '#888',
              fillOpacity: 0.5
            });
          }
        }
        if (feature.properties) {
          const name = feature.properties.name || feature.properties.Nom_Commun || 'Inconnu';
          layer.bindTooltip(`<strong>${name}</strong>`, {
            permanent: false, direction: 'top', offset: [0, -10], sticky: true
          }).openTooltip(e.latlng);
        }
      },
      mouseout: function (e) {
        if (currentRegionLayer !== layer) {
          if (currentLayerType === 'provinces' && provincesLayer) {
            provincesLayer.resetStyle(layer);
          } else if (currentLayerType === 'communes' && communesLayer) {
            communesLayer.resetStyle(layer);
          }
          layer.closeTooltip();
        }
      },
      click: function (e) {
        handleRegionClick(feature, layer);
      }
    });
  }

  function handleRegionClick(feature, layer) {
    if (currentRegionLayer !== layer) {
      resetAllRegions();
      clearAgencies();
      currentRegionLayer = layer;
      highlightRegion(layer);
      map.fitBounds(layer.getBounds());
      loadAgenciesWithinRegion(feature);

      const props = feature.properties;
      const score      = props.coverage_score;        // number or undefined
      const potential  = props.coverage_potential;
      let name = props.name || props.Nom_Commun || "Inconnu";
      let rma_count = props.rma_count || 0;
      let pop  = props.population || props.Population;
      let pop_insured = props.insured_population;
      let vehicles = props.estimated_vehicles;

      document.getElementById("region-name").textContent = name;
      document.getElementById("region-score").textContent    =
        score !== undefined ? score.toFixed(1) : "‚Äî";
      document.getElementById("region-potential").textContent=
          potential || "‚Äî";
      document.getElementById("region-rma-count").textContent = rma_count;
      document.getElementById("region-population").textContent = pop ? pop.toLocaleString() : "Donn√©e non disponible";
      document.getElementById("region-insured-population").textContent = pop_insured ? pop_insured.toLocaleString() : "Donn√©e non disponible";
      document.getElementById("region-vehicules").textContent = vehicles ? vehicles.toLocaleString() : "Donn√©e non disponible";

      document.getElementById("info-card").style.display = "block";
    }
  }

  // Province/Commune loaders
  function loadProvinces() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'provinces-geojson' %}")
    .then(res => res.json())
    .then(provinceData => {
      provinceRmaCounts = countRmaAgencies(provinceData, "province");
      const values = Object.values(provinceRmaCounts);
      provinceRmaMin = Math.min(...values);
      provinceRmaMax = Math.max(...values);

      /* ‚ú± pass renderer */
      provincesLayer = L.geoJSON(provinceData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    provinceStyle,
        onEachFeature
      }).addTo(map);

    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

function loadCommunes() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'communes-geojson' %}")
    .then(res => res.json())
    .then(communeData => {
      communeRmaCounts = countRmaAgencies(communeData, "commune");
      const values = Object.values(communeRmaCounts);
      communeRmaMin = Math.min(...values);
      communeRmaMax = Math.max(...values);

      communesLayer = L.geoJSON(communeData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    communeStyle,
        onEachFeature
      }).addTo(map);
    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

  function showLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "flex";
  }

  function hideLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "none";
  }




  // Load competitor and rma data
  Promise.all([
    fetch("{% url 'competitor-geojson' %}").then(res => res.json()),
    fetch("{% url 'rma-geojson' %}").then(res => res.json())
  ]).then(([comp, rma]) => {
    compData = comp;
    rmaData = rma;
    loadCurrentLayer(); // call something to decide what to render
  });
  function loadCurrentLayer() {
    if (provincesLayer) map.removeLayer(provincesLayer);
    if (communesLayer) map.removeLayer(communesLayer);
    if (currentLayerType === 'provinces') {
      loadProvinces();
    } else {
      loadCommunes();
    }
  }

  // Reset/clear on zoom out
  map.on("zoomend", () => {
    if (map.getZoom() < 8) {
      clearAgencies();
      resetAllRegions();
    }
  });
  map.on("zoom", () => {
    if (currentLayerType === 'communes' && map.getZoom() < 10) {
      clearAgencies();
    }
  });

</script>
<script>
  /* ---------------- CSRF helper ---------------- */
  // Better CSRF token retrieval
  function getCSRFToken() {
      // Try multiple methods
      let token = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!token) {
          token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
      }
      if (!token) {
          const cookieMatch = document.cookie.match(/csrftoken=([^;]*)/);
          token = cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;
      }
      return token;
  }

  const csrftoken = getCSRFToken();

async function exportPdf () {
  console.log('üî• exportPdf function started!');
  try {
    console.log('üì∏ Capturing map with leaflet-image‚Ä¶');

    /* 1Ô∏è‚É£  Get an exact PNG of the map layer */
    const imgData = await new Promise((resolve, reject) => {
      leafletImage(map, (err, canvas) => {
        if (err) return reject(err);
        resolve(canvas.toDataURL('image/png'));
      });
    });
    console.log('‚úÖ Map captured, size:', imgData.length);

        // Rest of your code...
        const payload = {
            img: imgData,
            title: document.getElementById('region-name')?.textContent || 'Vue g√©n√©rale',
            kpis: {
                score: document.getElementById('region-score')?.textContent,
                potential: document.getElementById('region-potential')?.textContent,
                population: document.getElementById('region-population')?.textContent,
                insured: document.getElementById('region-insured-population')?.textContent,
                vehicles: document.getElementById('region-vehicules')?.textContent,
                rma: document.getElementById('region-rma-count')?.textContent
            }
        };

        const payloadSize = JSON.stringify(payload).length;
        console.log('üìè Payload size (MB):', (payloadSize / 1024 / 1024).toFixed(2));

        console.log('üöÄ Sending request...');
        const res = await fetch("{% url 'export-pdf' %}", {
            method: 'POST',
            credentials: 'same-origin',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify(payload)
        });

        if (!res.ok) {
            const errorText = await res.text();
            console.error('‚ùå Error response:', errorText);
            alert('Erreur lors de la cr√©ation du PDF (' + res.status + '): ' + errorText);
            return;
        }

        const blob = await res.blob();
        saveAs(blob, 'RMA_report.pdf');
        console.log('‚úÖ PDF export completed!');
        
    } catch (error) {
        console.error('üí• Error in exportPdf:', error);
        alert('Erreur: ' + error.message);
    }
}
  // Better event listener attachment
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, looking for export button...');
    const exportBtn = document.getElementById('export-pdf-btn');
    
    if (!exportBtn) {
        console.error('‚ùå Export PDF button not found!');
        return;
    }
    
    console.log('‚úÖ Export PDF button found');
    exportBtn.addEventListener('click', function(e) {
        console.log('üñ±Ô∏è Export button clicked!');
        e.preventDefault(); // Prevent any default behavior
        exportPdf();
    });
});

</script>
{% endblock %}
