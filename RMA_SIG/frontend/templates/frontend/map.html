{# templates/map.html #}
{% extends "base.html" %}
{% load static %}

{% block head %}
  {{ block.super }}
  <link rel="stylesheet" href="{% static 'frontend_css/style.css' %}" />
{% endblock %}

{% block title %}Map — RMA SIG{% endblock %}

{% block scripts %}
<div id="toggle-container">
  <div class="toggle-switch" style="margin-left: 38px;">
    <span class="layer-label">Provinces</span>
    <label class="switch">
      <input type="checkbox" id="layer-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Communes</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px; margin-left: 38px;">
    <span class="layer-label">Normal</span>
    <label class="switch">
      <input type="checkbox" id="heatmap-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Heatmap</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px;">
    <span class="layer-label">All Agencies</span>
    <label class="switch">
      <input type="checkbox" id="rma-only-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">RMA Only</span>
  </div>
  <!-- Export button -->
  <button id="export-pdf-btn" class="export-btn"
          style="margin-top:8px;margin-left:10px;padding:6px 14px;
                background:#d35400;color:#fff;border:none;border-radius:6px;
                cursor:pointer;">
    Export PDF
  </button>
</div>

<div id="info-card" style="display: none; min-width: fit-content;">
  <h3 id="region-name"></h3>
  <!-- NEW -->
  <p><strong>Score de couverture&nbsp;(0-100):</strong>
     <span id="region-score"></span></p>
  <p><strong>Potentiel:</strong>
     <span id="region-potential"></span></p>

  <hr>
  <p><strong>Agences RMA:</strong> <span id="region-rma-count"></span></p>
  <p><strong>Population:</strong> <span id="region-population"></span></p>
  <p><strong>Population assurable:</strong> <span id="region-insured-population"></span></p>
  <p><strong>Nombre de vehicules estimées:</strong> <span id="region-vehicules"></span></p>
</div>

  
<div id="map"></div>
<div id="loading-screen" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(255, 255, 255, 0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  font-size: 1.5em;
  font-weight: bold;
  color: #333;
">
  Chargement des données...
</div>
<!-- overlay shown ONLY while the PDF is generated -->
<div id="export-overlay" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,.35);
  display: none;                       /* hidden by default */
  align-items: center; justify-content: center;
  z-index: 10000;
">
  <div style="
      background:#fff;
      padding:26px 32px;
      border-radius:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.3);
      font-size:1.1rem; font-weight:600;
      display:flex; align-items:center; gap:12px;">
    <span id="export-msg">Génération du PDF…</span>
    <svg class="spinner" viewBox="0 0 50 50" width="32" height="32">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#d35400"
              stroke-width="5" stroke-linecap="round"
              stroke-dasharray="31.4 31.4">
        <animateTransform attributeName="transform" type="rotate"
                          from="0 25 25" to="360 25 25"
                          dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-hash"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>


<script>
  // Centre initial sur le Maroc
  const map = L.map('map').setView([31.7, -7.1], 6);

  // Tuiles TomTom Orbis Maps (vue géopolitique marocaine)
  const tomtomUrl =
    'https://{s}.api.tomtom.com/maps/orbis/map-display/tile/{z}/{x}/{y}.png' +
    '?apiVersion=1&key=KMOHcDyNXgvQphFMEKmAOPXkr6MLkybG&style=street-light&tileSize=256&view=MA';

  L.tileLayer(tomtomUrl, {
    subdomains: 'abc',          // TomTom utilise a,b,c
    attribution: '© TomTom',
    maxZoom: 18
}).addTo(map);
  const canvasRenderer = L.canvas({ padding: 0.5 });


  let provincesLayer = null;
  let communesLayer = null;
  let agencyLayer = null;
  let currentRegionLayer = null;
  let currentLayerType = 'provinces';
  let heatmapActive = false;
  let rmaOnlyActive = false;
  let rmaData = null;
  let compData = null;
  let provinceRmaCounts = {};
  let communeRmaCounts = {};
  let provinceRmaMin = 0, provinceRmaMax = 1;
  let communeRmaMin = 0, communeRmaMax = 1;
  const hash = new L.Hash(map);
  // Utility for point in polygon
  function pointInPolygon(point, polygon) {
    const x = point[0], y = point[1];
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.00000001) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Count RMA agencies in each polygon (province/commune)
  function countRmaAgencies(geojson) {
    if (!rmaData) return {};
    const counts = {};
    geojson.features.forEach((feature, idx) => {
      let count = 0;
      const geom = feature.geometry;
      rmaData.features.forEach(pt => {
        const point = pt.geometry.coordinates;
        if (geom.type === "Polygon" && pointInPolygon(point, geom.coordinates[0])) count++;
        if (geom.type === "MultiPolygon" && geom.coordinates.some(poly => pointInPolygon(point, poly[0]))) count++;
      });
      feature.properties.rma_count = count;
      counts[feature.properties.code || idx] = count;
    });
    return counts;
  }

  function getColorGradient(val, min, max) {
    const ratio = (val - min) / (max - min + 0.00001);
    if (isNaN(ratio) || max == min) return '#eee';
    const r = Math.floor(255 * Math.min(2 * ratio, 1));
    const g = Math.floor(255 * Math.min(2 * (1 - ratio), 1));
    const b = Math.floor(255 * (1 - ratio));
    return `rgb(${r},${g},${b})`;
  }

  // Style functions
  function provinceStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'blue', weight: 2, fillOpacity: 0.3, fillColor: '#99ccff'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'blue', weight: 2,
      fillOpacity: 0.75,
      fillColor: getColorGradient(count, provinceRmaMin, provinceRmaMax)
    };
  }
  function communeStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'green', weight: 1, fillOpacity: 0.2, fillColor: '#aee'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'green', weight: 1,
      fillOpacity: 0.7,
      fillColor: getColorGradient(count, communeRmaMin, communeRmaMax)
    };
  }

  // Toggles
  document.getElementById('layer-toggle').addEventListener('change', function(e) {
    currentLayerType = this.checked ? 'communes' : 'provinces';
    resetView();
    loadCurrentLayer();
  });
  document.getElementById('heatmap-toggle').addEventListener('change', function(e) {
    heatmapActive = this.checked;
    loadCurrentLayer();
  });
  document.getElementById('rma-only-toggle').addEventListener('change', function(e) {
    rmaOnlyActive = this.checked;
    // If a region is already selected, reload agencies for that region
    if (currentRegionLayer && currentRegionLayer.feature) {
      loadAgenciesWithinRegion(currentRegionLayer.feature);
    }
  });

  function resetView() {
    resetAllRegions();
    clearAgencies();
    map.setView([29, -6], 6);
  }

  function resetAllRegions() {
    if (provincesLayer && currentLayerType === 'provinces') provincesLayer.resetStyle();
    if (communesLayer && currentLayerType === 'communes') communesLayer.resetStyle();
    currentRegionLayer = null;
    document.getElementById("info-card").style.display = "none";
  }

  function highlightRegion(layer) {
    layer.setStyle({
      color: "#d35400",
      weight: 4,
      fillOpacity: 0.5
    });
  }

  function clearAgencies() {
    if (agencyLayer) {
      map.removeLayer(agencyLayer);
      agencyLayer = null;
    }
  }

  // Show either all or only RMA agencies
  function loadAgenciesWithinRegion(regionFeature) {
    if (!compData || !rmaData) return;
    const regionGeometry = regionFeature.geometry;

    function isInRegion(point) {
      if (regionGeometry.type === "Polygon") return pointInPolygon(point, regionGeometry.coordinates[0]);
      if (regionGeometry.type === "MultiPolygon") return regionGeometry.coordinates.some(poly => pointInPolygon(point, poly[0]));
      return false;
    }

    const rmaFiltered = rmaData.features.filter(f => isInRegion(f.geometry.coordinates));
    const compFiltered = !rmaOnlyActive ? compData.features.filter(f => isInRegion(f.geometry.coordinates)) : [];
    const combined = [...rmaFiltered, ...compFiltered];

    if (agencyLayer) map.removeLayer(agencyLayer);

    agencyLayer = L.geoJSON({ type: "FeatureCollection", features: combined }, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => {
      const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        return L.circleMarker(latlng, {
          renderer: canvasRenderer,    
          radius: 6,
          fillColor: isRMA ? "#2980b9" : "#27ae60",
          color: "#fff",
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        if (isRMA) {
          const name = props.name || "Agence RMA";
          const address = props.address || "-";
          const city = props.city || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Adresse:</b> ${address}<br/><b>Ville:</b> ${city}`);
        } else {
          const name = props.company_name || "Agence";
          const address = props.address || "-";
          const city = props.city || "-";
          const mandante = props.mandante || "-";
          const competitor_type = props.competitor_type || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Mandante:</b> ${mandante}<br/><b>Type:</b> ${competitor_type}<br/><b>Adresse:</b> ${address}<br/><b>Localité:</b> ${city}`);
        }
      }
    }).addTo(map);
  }


  // Event for features
  function onEachFeature(feature, layer) {
    layer.on({
      mouseover: function (e) {
        if (currentRegionLayer !== layer) {
          if (heatmapActive) {
            layer.setStyle({
              fillColor: '#ffd700',
              fillOpacity: 0.8,
              weight: 4,
              color: '#888'
            });
          } else {
            layer.setStyle({
              weight: 4,
              color: '#888',
              fillOpacity: 0.5
            });
          }
        }
        if (feature.properties) {
          const name = feature.properties.name || feature.properties.Nom_Commun || 'Inconnu';
          layer.bindTooltip(`<strong>${name}</strong>`, {
            permanent: false, direction: 'top', offset: [0, -10], sticky: true
          }).openTooltip(e.latlng);
        }
      },
      mouseout: function (e) {
        if (currentRegionLayer !== layer) {
          if (currentLayerType === 'provinces' && provincesLayer) {
            provincesLayer.resetStyle(layer);
          } else if (currentLayerType === 'communes' && communesLayer) {
            communesLayer.resetStyle(layer);
          }
          layer.closeTooltip();
        }
      },
      click: function (e) {
        handleRegionClick(feature, layer);
      }
    });
  }

  function handleRegionClick(feature, layer) {
    if (currentRegionLayer !== layer) {
      resetAllRegions();
      clearAgencies();
      currentRegionLayer = layer;
      highlightRegion(layer);
      map.fitBounds(layer.getBounds());
      loadAgenciesWithinRegion(feature);

      const props = feature.properties;
      const score      = props.coverage_score;        // number or undefined
      const potential  = props.coverage_potential;
      let name = props.name || props.Nom_Commun || "Inconnu";
      let rma_count = props.rma_count || 0;
      let pop  = props.population || props.Population;
      let pop_insured = props.insured_population;
      let vehicles = props.estimated_vehicles;

      document.getElementById("region-name").textContent = name;
      document.getElementById("region-score").textContent    =
        score !== undefined ? score.toFixed(1) : "—";
      document.getElementById("region-potential").textContent=
          potential || "—";
      document.getElementById("region-rma-count").textContent = rma_count;
      document.getElementById("region-population").textContent = pop ? pop.toLocaleString() : "Donnée non disponible";
      document.getElementById("region-insured-population").textContent = pop_insured ? pop_insured.toLocaleString() : "Donnée non disponible";
      document.getElementById("region-vehicules").textContent = vehicles ? vehicles.toLocaleString() : "Donnée non disponible";

      document.getElementById("info-card").style.display = "block";
    }
  }

  // Province/Commune loaders
  function loadProvinces() {
  showLoading(); // ⏳ Show loader
  fetch("{% url 'provinces-geojson' %}")
    .then(res => res.json())
    .then(provinceData => {
      provinceRmaCounts = countRmaAgencies(provinceData, "province");
      const values = Object.values(provinceRmaCounts);
      provinceRmaMin = Math.min(...values);
      provinceRmaMax = Math.max(...values);

      /* ✱ pass renderer */
      provincesLayer = L.geoJSON(provinceData, {
        renderer: canvasRenderer,      // ← here
        style:    provinceStyle,
        onEachFeature
      }).addTo(map);

    })
    .finally(() => {
      hideLoading(); // ✅ Hide loader when done
    });
}

function loadCommunes() {
  showLoading(); // ⏳ Show loader
  fetch("{% url 'communes-geojson' %}")
    .then(res => res.json())
    .then(communeData => {
      communeRmaCounts = countRmaAgencies(communeData, "commune");
      const values = Object.values(communeRmaCounts);
      communeRmaMin = Math.min(...values);
      communeRmaMax = Math.max(...values);

      communesLayer = L.geoJSON(communeData, {
        renderer: canvasRenderer,      // ← here
        style:    communeStyle,
        onEachFeature
      }).addTo(map);
    })
    .finally(() => {
      hideLoading(); // ✅ Hide loader when done
    });
}

  function showLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "flex";
  }

  function hideLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "none";
  }




  // Load competitor and rma data
  Promise.all([
    fetch("{% url 'competitor-geojson' %}").then(res => res.json()),
    fetch("{% url 'rma-geojson' %}").then(res => res.json())
  ]).then(([comp, rma]) => {
    compData = comp;
    rmaData = rma;
    loadCurrentLayer(); // call something to decide what to render
  });
  function loadCurrentLayer() {
    if (provincesLayer) map.removeLayer(provincesLayer);
    if (communesLayer) map.removeLayer(communesLayer);
    if (currentLayerType === 'provinces') {
      loadProvinces();
    } else {
      loadCommunes();
    }
  }

  function showExportOverlay(msg='Génération du PDF…') {
    document.getElementById('export-msg').textContent = msg;
    document.getElementById('export-overlay').style.display = 'flex';
  }
  function hideExportOverlay() {
    document.getElementById('export-overlay').style.display = 'none';
  }

  // Reset/clear on zoom out
  map.on("zoomend", () => {
    if (map.getZoom() < 8) {
      clearAgencies();
      resetAllRegions();
    }
  });
  map.on("zoom", () => {
    if (currentLayerType === 'communes' && map.getZoom() < 10) {
      clearAgencies();
    }
  });

</script>
<script>
  /* ---------------- CSRF helper ---------------- */
  // Better CSRF token retrieval
  function getCSRFToken() {
      // Try multiple methods
      let token = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!token) {
          token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
      }
      if (!token) {
          const cookieMatch = document.cookie.match(/csrftoken=([^;]*)/);
          token = cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;
      }
      return token;
  }

  const csrftoken = getCSRFToken();

async function exportPdf() {
  console.log('🔥 exportPdf function started!');
  try {
    /* 1️⃣  Capture the map ------------------------------------------------ */
    showExportOverlay('Capture de la carte…');
    const imgData = await new Promise((resolve, reject) => {
      leafletImage(map, (err, canvas) => {
        if (err) return reject(err);
        resolve(canvas.toDataURL('image/png'));   // crisp PNG
      });
    });
    console.log('✅ Map captured, size:', imgData.length);

    /* 2️⃣  Build payload -------------------------------------------------- */
    const payload = {
      img:   imgData,
      title: document.getElementById('region-name')?.textContent || 'Vue générale',
      kpis: {
        score:      document.getElementById('region-score')?.textContent,
        potential:  document.getElementById('region-potential')?.textContent,
        population: document.getElementById('region-population')?.textContent,
        insured:    document.getElementById('region-insured-population')?.textContent,
        vehicles:   document.getElementById('region-vehicules')?.textContent,
        rma:        document.getElementById('region-rma-count')?.textContent
      }
    };

    /* 3️⃣  Send to backend ------------------------------------------------- */
    showExportOverlay('Génération du PDF…');
    const res = await fetch("{% url 'export-pdf' %}", {
      method:      'POST',
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken':  csrftoken                  // <-- token you fetched earlier
      },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const txt = await res.text();
      hideExportOverlay();
      console.error('❌ Error response:', txt);
      alert('Erreur lors de la création du PDF (' + res.status + '): ' + txt);
      return;
    }

    /* 4️⃣  Download ------------------------------------------------------- */
    showExportOverlay('Téléchargement…');
    const blob = await res.blob();
    saveAs(blob, 'RMA_report.pdf');
    console.log('✅ PDF export completed!');

  } catch (err) {
    console.error('💥 Error in exportPdf:', err);
    alert('Erreur: ' + err.message);
  } finally {
    hideExportOverlay();                 // always hide, success or fail
  }
}
  // Better event listener attachment
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, looking for export button...');
    const exportBtn = document.getElementById('export-pdf-btn');
    
    if (!exportBtn) {
        console.error('❌ Export PDF button not found!');
        return;
    }
    
    console.log('✅ Export PDF button found');
    exportBtn.addEventListener('click', function(e) {
        console.log('🖱️ Export button clicked!');
        e.preventDefault(); // Prevent any default behavior
        exportPdf();
    });
});

</script>
{% endblock %}
