{# templates/map.html #}
{% extends "base.html" %}
{% load static %}

{% block head %}
  {{ block.super }}
  <link rel="stylesheet" href="{% static 'frontend_css/style.css' %}" />
{% endblock %}

{% block title %}Map ‚Äî RMA SIG{% endblock %}

{% block scripts %}
<div id="toggle-container">
  <div class="toggle-switch">
    <form id="search-box" class="search-box leaflet-control">
      <input id="search-input"
            type="text"
            placeholder="Rechercher une ville"
            autocomplete="off" />
      <button type="submit" aria-label="Rechercher"></button>
    </form>
  </div>
  <div class="toggle-switch" style="margin-left: 38px;">
    <span class="layer-label">Provinces</span>
    <label class="switch">
      <input type="checkbox" id="layer-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Communes</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px; margin-left: 38px;">
    <span class="layer-label">Normal</span>
    <label class="switch">
      <input type="checkbox" id="heatmap-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">Heatmap</span>
  </div>
  <div class="toggle-switch" style="margin-top:8px;">
    <span class="layer-label">All Agencies</span>
    <label class="switch">
      <input type="checkbox" id="rma-only-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">RMA Only</span>
  </div>
   <div class="toggle-switch" style="margin-top:8px;margin-left: 87px;">
    <span class="layer-label">normal</span>
    <label class="switch">
      <input type="checkbox" id="score-toggle">
      <span class="slider"></span>
    </label>
    <span class="layer-label">coverage score</span>
  </div>
  <!-- Exp
  <!-- Export button -->
  <button id="export-pdf-btn" class="export-btn"
          style="margin-top:8px;margin-left:10px;padding:6px 14px;
                background:#d35400;color:#fff;border:none;border-radius:6px;
                cursor:pointer;">
    Export PDF
  </button>
</div>

<div id="info-card" style="display: none; min-width: fit-content;">
  <h3 id="region-name"></h3>
  <!-- NEW -->
  <p><strong>Score de couverture&nbsp;(0-100):</strong>
     <span id="region-score"></span></p>
  <p><strong>Potentiel:</strong>
     <span id="region-potential"></span></p>

  <hr>
  <p><strong>Agences RMA:</strong> <span id="region-rma-count"></span></p>
  <p><strong>Population:</strong> <span id="region-population"></span></p>
  <p><strong>Population assurable:</strong> <span id="region-insured-population"></span></p>
  <p><strong>Nombre de vehicules estim√©es:</strong> <span id="region-vehicules"></span></p>
</div>

  
<div id="map"></div>
<div id="loading-screen" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(255, 255, 255, 0.85);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 9999;
  font-size: 1.5em;
  font-weight: bold;
  color: #333;
">
  Chargement des donn√©es...
</div>
<!-- overlay shown ONLY while the PDF is generated -->
<div id="export-overlay" style="
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  background: rgba(0,0,0,.35);
  display: none;                       /* hidden by default */
  align-items: center; justify-content: center;
  z-index: 10000;
">
  <div style="
      background:#fff;
      padding:26px 32px;
      border-radius:12px;
      box-shadow:0 2px 8px rgba(0,0,0,.3);
      font-size:1.1rem; font-weight:600;
      display:flex; align-items:center; gap:12px;">
    <span id="export-msg">G√©n√©ration du PDF‚Ä¶</span>
    <svg class="spinner" viewBox="0 0 50 50" width="32" height="32">
      <circle cx="25" cy="25" r="20" fill="none" stroke="#d35400"
              stroke-width="5" stroke-linecap="round"
              stroke-dasharray="31.4 31.4">
        <animateTransform attributeName="transform" type="rotate"
                          from="0 25 25" to="360 25 25"
                          dur="1s" repeatCount="indefinite"/>
      </circle>
    </svg>
  </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-providers@1.13.0/leaflet-providers.min.js"></script>      <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-fullscreen@1.6.0/Control.FullScreen.js"></script>                    <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>         <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-minimap@3.6.1/dist/Control.MiniMap.min.js"></script>                 <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.js"></script>                     <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>           <!-- ‚ú± NEW -->
<script src="https://unpkg.com/leaflet-hash"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://unpkg.com/leaflet-image@0.4.0/leaflet-image.js"></script>
<script src="https://unpkg.com/leaflet-easyprint@2.1.9/dist/bundle.js"></script> 
<link rel="stylesheet" href="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.css">
<script src="https://unpkg.com/leaflet-measure@3.3.0/dist/leaflet-measure.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-providers@1.14.0/leaflet-providers.min.js"></script>
<script src="https://unpkg.com/chroma-js@2.4.2/chroma.min.js"></script>



<script>
  // 1Ô∏è‚É£  create two basemaps + control
  const tomtom = L.tileLayer(
    'https://{s}.api.tomtom.com/maps/orbis/map-display/tile/{z}/{x}/{y}.png' +
    '?apiVersion=1&key=KMOHcDyNXgvQphFMEKmAOPXkr6MLkybG&style=street-light&tileSize=256&view=MA',
    {subdomains:'abc', maxZoom:18, attribution:'¬© TomTom'});

  const sat     = L.tileLayer.provider('Esri.WorldImagery');

  const baseLayers = {
    'TomTom MA': tomtom,
    'Satellite':  sat
  };

  // 2Ô∏è‚É£  init map with TomTom
  const map = L.map('map', {layers:[tomtom]}).setView([31.7, -7.1], 6);
  L.control.layers(baseLayers, null, {position:'bottomleft'}).addTo(map);         // ‚ú± NEW

  // 3Ô∏è‚É£  fullscreen button
  if (L.control.fullscreen)  map.addControl(new L.Control.Fullscreen());

  // 4Ô∏è‚É£  scale bar
  L.control.scale({position:'bottomleft'}).addTo(map);                          // ‚ú± NEW
;                                                                // ‚ú± NEW

  // 7Ô∏è‚É£  geocoder (search bar)
  (function(){
  const form   = document.getElementById('search-box');
  const input  = document.getElementById('search-input');
  const engine = L.Control.Geocoder.nominatim();   // moteur de recherche

  // Emp√™che la carte de bouger quand on clique sur le champ
  L.DomEvent.disableClickPropagation(form);
  L.DomEvent.disableScrollPropagation(form);

  form.addEventListener('submit', e=>{
    e.preventDefault();
    const q = input.value.trim();
    if(!q) return;
    engine.geocode(q, results=>{
      if(results && results.length){
        map.fitBounds(results[0].bbox);   // zoom sur le 1er r√©sultat
      }else{
        alert('Adresse introuvable');
      }
    });
  });
})();                                 // ‚ú± NEW


  const canvasRenderer = L.canvas({ padding: 0.5 });
  let provincesLayer = null;
  let communesLayer = null;
  let agencyLayer = null;
  let currentRegionLayer = null;
  let currentLayerType = 'provinces';
  let heatmapActive = false;
  let rmaOnlyActive = false;
  let rmaData = null;
  let compData = null;
  let provinceRmaCounts = {};
  let communeRmaCounts = {};
  let provinceRmaMin = 0, provinceRmaMax = 1;
  let communeRmaMin = 0, communeRmaMax = 1;
  const hash = new L.Hash(map);
  const SCORE_URL = {
    provinces : "{% url 'province-scores-geojson' %}",
    communes  : "{% url 'commune-scores-geojson' %}"
  };
  let scoreLayer = { provinces:null, communes:null };   // m√©moires s√©par√©es
  let scoreLegend = null;  

  const groups = {
    provinces : L.layerGroup().addTo(map),
    communes  : L.layerGroup().addTo(map)
  };

  function activeGroup(){
    return groups[currentLayerType];          // renvoie le groupe courant
  }

  function purgeGroup(type){
    groups[type].clearLayers();
  }

  function purgeAll(){
    groups.provinces.clearLayers();
    groups.communes.clearLayers();
    if(scoreLegend)  map.removeControl(scoreLegend);
  }

  // Utility for point in polygon
  function pointInPolygon(point, polygon) {
    const x = point[0], y = point[1];
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0], yi = polygon[i][1];
      const xj = polygon[j][0], yj = polygon[j][1];
      const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / ((yj - yi) + 0.00000001) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Count RMA agencies in each polygon (province/commune)
  function countRmaAgencies(geojson) {
    if (!rmaData) return {};
    const counts = {};
    geojson.features.forEach((feature, idx) => {
      let count = 0;
      const geom = feature.geometry;
      rmaData.features.forEach(pt => {
        const point = pt.geometry.coordinates;
        if (geom.type === "Polygon" && pointInPolygon(point, geom.coordinates[0])) count++;
        if (geom.type === "MultiPolygon" && geom.coordinates.some(poly => pointInPolygon(point, poly[0]))) count++;
      });
      feature.properties.rma_count = count;
      counts[feature.properties.code || idx] = count;
    });
    return counts;
  }

  function getColorGradient(val, min, max) {
    const ratio = (val - min) / (max - min + 0.00001);
    if (isNaN(ratio) || max == min) return '#eee';
    const r = Math.floor(255 * Math.min(2 * ratio, 1));
    const g = Math.floor(255 * Math.min(2 * (1 - ratio), 1));
    const b = Math.floor(255 * (1 - ratio));
    return `rgb(${r},${g},${b})`;
  }

  // Style functions
  function provinceStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'blue', weight: 2, fillOpacity: 0.3, fillColor: '#99ccff'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'blue', weight: 2,
      fillOpacity: 0.75,
      fillColor: getColorGradient(count, provinceRmaMin, provinceRmaMax)
    };
  }
  function communeStyle(feature) {
    if (!heatmapActive) {
      return {
        color: 'green', weight: 1, fillOpacity: 0.2, fillColor: '#aee'
      };
    }
    let count = feature.properties.rma_count || 0;
    return {
      color: 'green', weight: 1,
      fillOpacity: 0.7,
      fillColor: getColorGradient(count, communeRmaMin, communeRmaMax)
    };
  }

  // Toggles
  document.getElementById('layer-toggle').addEventListener('change', function(e) {
    currentLayerType = this.checked ? 'communes' : 'provinces';
    resetView();
    loadCurrentLayer();
  });
  document.getElementById('heatmap-toggle').addEventListener('change', function(e) {
    heatmapActive = this.checked;
    loadCurrentLayer();
  });
  document.getElementById('rma-only-toggle').addEventListener('change', function(e) {
    rmaOnlyActive = this.checked;
    // If a region is already selected, reload agencies for that region
    if (currentRegionLayer && currentRegionLayer.feature) {
      loadAgenciesWithinRegion(currentRegionLayer.feature);
    }
  });

  function resetView(){
      purgeAll();               // vide les deux groupes
      clearAgencies();          // (facultatif, pour √™tre s√ªr)
      map.setView([29,-6],6);
      document.getElementById("info-card").style.display = "none";
  }

  function resetAllRegions() {
    if (provincesLayer && currentLayerType === 'provinces') provincesLayer.resetStyle();
    if (communesLayer && currentLayerType === 'communes') communesLayer.resetStyle();
    currentRegionLayer = null;
    document.getElementById("info-card").style.display = "none";
  }

  function highlightRegion(layer) {
    layer.setStyle({
      color: "#d35400",
      weight: 4,
      fillOpacity: 0.5
    });
  }

  function clearAgencies() {
    if (agencyLayer) {
      map.removeLayer(agencyLayer);
      agencyLayer = null;
    }
  }

  // Show either all or only RMA agencies
  function loadAgenciesWithinRegion(regionFeature) {
    if (!compData || !rmaData) return;
    const regionGeometry = regionFeature.geometry;

    function isInRegion(point) {
      if (regionGeometry.type === "Polygon") return pointInPolygon(point, regionGeometry.coordinates[0]);
      if (regionGeometry.type === "MultiPolygon") return regionGeometry.coordinates.some(poly => pointInPolygon(point, poly[0]));
      return false;
    }

    const rmaFiltered = rmaData.features.filter(f => isInRegion(f.geometry.coordinates));
    const compFiltered = !rmaOnlyActive ? compData.features.filter(f => isInRegion(f.geometry.coordinates)) : [];
    const combined = [...rmaFiltered, ...compFiltered];

    if (agencyLayer) map.removeLayer(agencyLayer);

    agencyLayer = L.geoJSON({ type: "FeatureCollection", features: combined }, {
      renderer: canvasRenderer,
      pointToLayer: (feature, latlng) => {
      const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        return L.circleMarker(latlng, {
          renderer: canvasRenderer,    
          radius: 6,
          fillColor: isRMA ? "#2980b9" : "#27ae60",
          color: "#fff",
          weight: 1,
          opacity: 1,
          fillOpacity: 0.9
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties;
        const isRMA = feature.properties.name && feature.properties.address && feature.properties.city;
        if (isRMA) {
          const name = props.name || "Agence RMA";
          const address = props.address || "-";
          const city = props.city || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Adresse:</b> ${address}<br/><b>Ville:</b> ${city}`);
        } else {
          const name = props.company_name || "Agence";
          const address = props.address || "-";
          const city = props.city || "-";
          const mandante = props.mandante || "-";
          const competitor_type = props.competitor_type || "-";
          layer.bindPopup(`<strong>${name}</strong><br/><b>Mandante:</b> ${mandante}<br/><b>Type:</b> ${competitor_type}<br/><b>Adresse:</b> ${address}<br/><b>Localit√©:</b> ${city}`);
        }
      }
    }).addTo(activeGroup());;
  }


  // Event for features
  function onEachFeature(feature, layer) {
    layer.on({
      mouseover: function (e) {
        if (currentRegionLayer !== layer) {
          if (heatmapActive) {
            layer.setStyle({
              fillColor: '#ffd700',
              fillOpacity: 0.8,
              weight: 4,
              color: '#888'
            });
          } else {
            layer.setStyle({
              weight: 4,
              color: '#888',
              fillOpacity: 0.5
            });
          }
        }
        if (feature.properties) {
          const name = feature.properties.name || feature.properties.Nom_Commun || 'Inconnu';
          layer.bindTooltip(`<strong>${name}</strong>`, {
            permanent: false, direction: 'top', offset: [0, -10], sticky: true
          }).openTooltip(e.latlng);
        }
      },
      mouseout: function (e) {
        if (currentRegionLayer !== layer) {
          if (currentLayerType === 'provinces' && provincesLayer) {
            provincesLayer.resetStyle(layer);
          } else if (currentLayerType === 'communes' && communesLayer) {
            communesLayer.resetStyle(layer);
          }
          layer.closeTooltip();
        }
      },
      click: function (e) {
        handleRegionClick(feature, layer);
      }
    });
  }

  function handleRegionClick(feature, layer) {
    if (currentRegionLayer !== layer) {
      resetAllRegions();
      clearAgencies();
      currentRegionLayer = layer;
      highlightRegion(layer);
      map.fitBounds(layer.getBounds());
      loadAgenciesWithinRegion(feature);

      const props = feature.properties;
      const score      = props.coverage_score;        // number or undefined
      const potential  = props.coverage_potential;
      let name = props.name || props.Nom_Commun || "Inconnu";
      let rma_count = props.rma_count || 0;
      let pop  = props.population || props.Population;
      let pop_insured = props.insured_population;
      let vehicles = props.estimated_vehicles;

      document.getElementById("region-name").textContent = name;
      document.getElementById("region-score").textContent    =
        score !== undefined ? score.toFixed(1) : "‚Äî";
      document.getElementById("region-potential").textContent=
          potential || "‚Äî";
      document.getElementById("region-rma-count").textContent = rma_count;
      document.getElementById("region-population").textContent = pop ? pop.toLocaleString() : "Donn√©e non disponible";
      document.getElementById("region-insured-population").textContent = pop_insured ? pop_insured.toLocaleString() : "Donn√©e non disponible";
      document.getElementById("region-vehicules").textContent = vehicles ? vehicles.toLocaleString() : "Donn√©e non disponible";

      document.getElementById("info-card").style.display = "block";
    }
  }

  // Province/Commune loaders
  function loadProvinces() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'provinces-geojson' %}")
    .then(res => res.json())
    .then(provinceData => {
      provinceRmaCounts = countRmaAgencies(provinceData, "province");
      const values = Object.values(provinceRmaCounts);
      provinceRmaMin = Math.min(...values);
      provinceRmaMax = Math.max(...values);

      /* ‚ú± pass renderer */
      provincesLayer = L.geoJSON(provinceData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    provinceStyle,
        onEachFeature
      }).addTo(groups.provinces);

    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

function loadCommunes() {
  showLoading(); // ‚è≥ Show loader
  fetch("{% url 'communes-geojson' %}")
    .then(res => res.json())
    .then(communeData => {
      communeRmaCounts = countRmaAgencies(communeData, "commune");
      const values = Object.values(communeRmaCounts);
      communeRmaMin = Math.min(...values);
      communeRmaMax = Math.max(...values);

      communesLayer = L.geoJSON(communeData, {
        renderer: canvasRenderer,      // ‚Üê here
        style:    communeStyle,
        onEachFeature
      }).addTo(groups.communes);
    })
    .finally(() => {
      hideLoading(); // ‚úÖ Hide loader when done
    });
}

  function showLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "flex";
  }

  function hideLoading() {
    const loader = document.getElementById("loading-screen");
    if (loader) loader.style.display = "none";
  }




  // Load competitor and rma data
  Promise.all([
    fetch("{% url 'competitor-geojson' %}").then(res => res.json()),
    fetch("{% url 'rma-geojson' %}").then(res => res.json())
  ]).then(([comp, rma]) => {
    compData = comp;
    rmaData = rma;
    loadCurrentLayer(); // call something to decide what to render
  });
  function loadCurrentLayer() {
    purgeGroup(currentLayerType);   // ‚¨ÖÔ∏è  NEW : on efface d‚Äôabord la couche courante

    if (currentLayerType === 'provinces') {
      loadProvinces();
    } else {
      loadCommunes();
    }
  }

  function showExportOverlay(msg='G√©n√©ration du PDF‚Ä¶') {
    document.getElementById('export-msg').textContent = msg;
    document.getElementById('export-overlay').style.display = 'flex';
  }
  function hideExportOverlay() {
    document.getElementById('export-overlay').style.display = 'none';
  }
  

  // Reset/clear on zoom out
  map.on("zoomend", () => {
    if (map.getZoom() < 8) {
      clearAgencies();
      resetAllRegions();
    }
  });
  map.on("zoom", () => {
    if (currentLayerType === 'communes' && map.getZoom() < 10) {
      clearAgencies();
    }
  });

  function getScoreColor(val, min, max){
    // Handle undefined/null values
    if (val == null || isNaN(val)) {
        return '#cccccc'; // Gray color for missing data
    }
    
    // assurez-vous que chroma.min.js est d√©j√† charg√© avant ce code
    return chroma.scale(['#fee5d9','#fcae91','#fb6a4a','#de2d26','#a50f15'])
                .domain([min, max])(val)
                .hex();
}

function buildScoreLayer(adminType, callback){
    showLoading();
    fetch(SCORE_URL[adminType])
        .then(r=>{ if(!r.ok) throw Error(r.statusText); return r.json(); })
        .then(fc=>{
            // Filter out features with invalid scores - using coverage_score instead of score
            const validScores = fc.features
                .map(f => f.properties.coverage_score)
                .filter(score => score != null && !isNaN(score) && score !== '');
            
            // Check if we have any valid scores
            if (validScores.length === 0) {
                throw new Error("Aucun coverage_score valide trouv√© dans les donn√©es");
            }
            
            const min = Math.min(...validScores);
            const max = Math.max(...validScores);

            const layer = L.geoJSON(fc, {
                style: f => ({
                    weight: 1,
                    color: '#666',
                    fillOpacity: .8,
                    fillColor: getScoreColor(f.properties.coverage_score, min, max)
                }),
                onEachFeature: (f, l) => {
                    const score = f.properties.coverage_score;
                    const scoreText = (score != null && !isNaN(score)) 
                        ? score.toFixed(1) 
                        : 'N/A';
                    
                    l.bindPopup(`<strong>${f.properties.name}</strong><br>` +
                               `Coverage Score : ${scoreText}`);
                }
            }).addTo(groups[adminType]);

            callback(layer, min, max);
        })
        .catch(err => alert("Erreur score : " + err))
        .finally(hideLoading);
}

function showScoreLayer(){
    const t = currentLayerType;

    purgeGroup(t);            // ‚¨ÖÔ∏è  ENL√àVE provinces/communes (heat-map ou non)


    // si d√©j√† pr√©sent ‚áí juste l'ajouter
    if(scoreLayer[t]){
        map.addLayer(scoreLayer[t]);
        addOrUpdateLegend(scoreLayer[t]._min, scoreLayer[t]._max);
        return;
    }

    // sinon : t√©l√©charger, construire et m√©moriser
    buildScoreLayer(t, (lyr,min,max)=>{
        scoreLayer[t] = lyr;
        scoreLayer[t]._min = min;
        scoreLayer[t]._max = max;
        map.addLayer(lyr);
        addOrUpdateLegend(min,max);
    });
}

function hideScoreLayer(type = currentLayerType){
    if (scoreLayer[type]) {
        map.removeLayer(scoreLayer[type]);
        scoreLayer[type] = null;          // lib√®re la m√©moire
    }
    if (scoreLegend) {
        map.removeControl(scoreLegend);
        scoreLegend = null;
    }
}

function addOrUpdateLegend(min,max){
    if(scoreLegend) map.removeControl(scoreLegend);

    scoreLegend = L.control({position:'bottomright'});
    scoreLegend.onAdd = ()=>{
        const div = L.DomUtil.create('div','info legend');
        const step = (max-min)/5;
        for(let i=0;i<5;i++){
            const v0=(min+i*step).toFixed(0), v1=(min+(i+1)*step).toFixed(0);
            div.innerHTML +=
                `<i style="background:${getScoreColor((+v0+ +v1)/2,min,max)}"></i> `
                +`${v0}&ndash;${v1}<br>`;
        }
        return div;
    };
    scoreLegend.addTo(map);
}

function clearEverything() {
  // remove all base geo-json
  groups.provinces.clearLayers();
  groups.communes.clearLayers();

  // remove any scoropleth
  Object.values(scoreLayer).forEach(layer => {
    if (layer) { 
      map.removeLayer(layer);
    }
  });
  scoreLayer.provinces = scoreLayer.communes = null;
  if (scoreLegend) { map.removeControl(scoreLegend); scoreLegend = null; }

  // remove agency markers
  if (agencyLayer) {
    map.removeLayer(agencyLayer);
    agencyLayer = null;
  }
}

// Get references to toggles
const scoreToggle = document.getElementById('score-toggle');
const layerToggle = document.getElementById('layer-toggle');
const heatmapToggle = document.getElementById('heatmap-toggle');
const rmaOnlyToggle = document.getElementById('rma-only-toggle');

/* 2-a  Provinces ‚Üî Communes -------------------------------------------------*/
// 1) Layer (Provinces ‚Üî Communes)
layerToggle.addEventListener('change', e => {
  clearEverything();
  currentLayerType = e.target.checked ? 'communes' : 'provinces';
  loadCurrentLayer();
  if (scoreToggle.checked) showScoreLayer();
});

// 2) Heatmap on/off
heatmapToggle.addEventListener('change', e => {
  if (scoreToggle.checked) {
    // can‚Äôt have both
    e.target.checked = false;
    return;
  }
  clearEverything();
  heatmapActive = e.target.checked;
  loadCurrentLayer();
});

// 3) Coverage-Score on/off
scoreToggle.addEventListener('change', e => {
  // turn off heatmap if needed
  if (e.target.checked && heatmapToggle.checked) {
    heatmapToggle.checked = false;
    heatmapActive = false;
  }
  clearEverything();
  if (e.target.checked) {
    showScoreLayer();
  } else {
    loadCurrentLayer();
  }
});

// 4) RMA-Only just needs to reload the markers on the current region
rmaOnlyToggle.addEventListener('change', e => {
  rmaOnlyActive = e.target.checked;
  if (currentRegionLayer && currentRegionLayer.feature) {
    loadAgenciesWithinRegion(currentRegionLayer.feature);
  }
});

</script>
<script>
  /* ---------------- CSRF helper ---------------- */
  // Better CSRF token retrieval
  function getCSRFToken() {
      // Try multiple methods
      let token = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
      if (!token) {
          token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
      }
      if (!token) {
          const cookieMatch = document.cookie.match(/csrftoken=([^;]*)/);
          token = cookieMatch ? decodeURIComponent(cookieMatch[1]) : null;
      }
      return token;
  }

  const csrftoken = getCSRFToken();

async function exportPdf() {
  console.log('üî• exportPdf function started!');
  try {
    /* 1Ô∏è‚É£  Capture the map ------------------------------------------------ */
    showExportOverlay('Capture de la carte‚Ä¶');
    const imgData = await new Promise((resolve, reject) => {
      leafletImage(map, (err, canvas) => {
        if (err) return reject(err);
        resolve(canvas.toDataURL('image/png'));   // crisp PNG
      });
    });
    console.log('‚úÖ Map captured, size:', imgData.length);

    /* 2Ô∏è‚É£  Build payload -------------------------------------------------- */
    const payload = {
      img:   imgData,
      title: document.getElementById('region-name')?.textContent || 'Vue g√©n√©rale',
      kpis: {
        score:      document.getElementById('region-score')?.textContent,
        potential:  document.getElementById('region-potential')?.textContent,
        population: document.getElementById('region-population')?.textContent,
        insured:    document.getElementById('region-insured-population')?.textContent,
        vehicles:   document.getElementById('region-vehicules')?.textContent,
        rma:        document.getElementById('region-rma-count')?.textContent
      }
    };

    /* 3Ô∏è‚É£  Send to backend ------------------------------------------------- */
    showExportOverlay('G√©n√©ration du PDF‚Ä¶');
    const res = await fetch("{% url 'export-pdf' %}", {
      method:      'POST',
      credentials: 'same-origin',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken':  csrftoken                  // <-- token you fetched earlier
      },
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      const txt = await res.text();
      hideExportOverlay();
      console.error('‚ùå Error response:', txt);
      alert('Erreur lors de la cr√©ation du PDF (' + res.status + '): ' + txt);
      return;
    }

    /* 4Ô∏è‚É£  Download ------------------------------------------------------- */
    showExportOverlay('T√©l√©chargement‚Ä¶');
    const blob = await res.blob();
    saveAs(blob, 'RMA_report.pdf');
    console.log('‚úÖ PDF export completed!');

  } catch (err) {
    console.error('üí• Error in exportPdf:', err);
    alert('Erreur: ' + err.message);
  } finally {
    hideExportOverlay();                 // always hide, success or fail
  }
}
  // Better event listener attachment
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, looking for export button...');
    const exportBtn = document.getElementById('export-pdf-btn');
    
    if (!exportBtn) {
        console.error('‚ùå Export PDF button not found!');
        return;
    }
    
    console.log('‚úÖ Export PDF button found');
    exportBtn.addEventListener('click', function(e) {
        console.log('üñ±Ô∏è Export button clicked!');
        e.preventDefault(); // Prevent any default behavior
        exportPdf();
    });
});

</script>
{% endblock %}
